* Estructura
  En esquema simplificado de la estructura se muestra a continuacion

  [[file:./schematics/bloques-top.png]]
  /Estructura para un caso con 2 modulos de convolucion/

  El siguiente esquema muestra con mas detalles los puertos de cada uno de los bloques

  [[file:./schematics/ports_with_buses.jpg]]
  
  A continuacion se hace una descripcion mas detallada de cada uno de los bloques
** Modulo de convolucion

   El modulo de convolucion se encarga de hacer un producto interno de Frobenius entre una matriz precargada llamada Kernel (filtro), y un sector de una imagen. El sector tiene la misma dimension que el kernel.

*** Estructura interna
    El modulo tiene dos arreglos de registros, en uno esta cargado el kernel, el cual solo se ve modificado durante la configuracion. El otro arreglo tiene cargado la porcion de la imagen.
    Una vez entregado un resultado, el arreglo que contiene la imagen desplaza sus filas hacia arriba, perdiendo la fila superior y cargando como fila inferior los valores que tiene en los puertos de entrada.
    La salida de la operacion aumenta el rango de bits de trabajo, por lo que se debe reajustar el rango antes de ponerlo a la salida.

**** I/O
     *Input*
     - _InputN_: 3 puertos de $BITS_IMAGEN bits que leen las filas de la imagen cargada en memoria, o las filas del kernel, dependiendo de los valores que tome el puerto *K/I*
     - _K/I_: Puerto de un bit que determina si los valores leidos en *InputN* se deben cargar en el kernel o en el registro de la imagen. Cualquier modificacion dependera del estado leido en *valid*.
       + Si se escribe un 1 en el puerto, el kernel sera modificado
       + Si se escribe un 0 en el puerto, la imagen sera modificada
       Durante un uso normal (fuera de la etapa de configuracion), deberia haber un 0 en el puerto
     - _Valid_: Habilita la modificacion de los registros si hay un estado alto en el puerto
       + Si se escribe un 1, los registros son modificados con cada flanco de clock.
       + Si se escribe un 0, los registros permanecen intactos.
     - _Reset_
     - _Clk_
     *OutPut*
     - _Out_: Salida de $BITS_IMAGEN que representa el resultado de las operaciones
    
** Modulo de control
**** I/O
     *Input*
     - i_GPIOvalid   : bit de valid asignado del bus del GPIO ( GPIO[28]).
     - i_GPIOctrl    : Puerto de 3 bits que recibe las instrucciones de control   GPIO[31:29].
     - i_GPIOdata    : Puerto de 24 bits que recibe los datos desde el exterior (GPIO[24:1])
     - i_rst         : reset del módulo(GPIO[0])
     - i_CLK         : entrada de clock
     - i_EOP_from_FSM: Proveniente de la FSM, indica que se ha finalizado la etapa de procesamiento, se debe salir del estado de *RUN*
     - i_MCUdata     : Puerto de 13 bits que recibe los datos almacenados en memoria (interactuando con el MCU)
     
     *OutPut*
     - o_GPIOdata      : Puerto de 32 bits utilizado para enviar informacion al exterior
     - o_MCUdata       : Puerto de [13] bits que reflejan los datos recibidos desde *GPIO_Data_In* durante la etapa de carga de imagen en el estado de *LOAD*
     - o_led           : Puerto de 3 bits a modo indicativo para referenciar el estado
     - o_SoP           : Indica que se ha pasado al estado de *RUN* y se debe comenzar el procesamiento de la informacion
     - o_EOP_to_MCU    : Indica (al MCU) que se ha pasado al estado de *OUT*
     - o_valid_to_FSM  : Se pone en estado alto durante un ciclo cuando detecta un flanco de subida del *bit Valid* de la instruccion de control presente en *GPIO_CTRL_In*
     - o_valid_to_CONV : Se pone en estado alto durante un ciclo cuando detecta un flanco de subida del *bit Valid* de la instruccion de control presente en *GPIO_CTRL_In* /unicamente durante la etapa de configuracion del kernel en la estapa de LOAD/
     - o_imgLength: Puerto de [10] bits que tiene a su salida la altura de la imagen con la que se esta trabajando
     - o_KNLdata       : Puerto de [24] bits que representan una fila del kernel (filtro) que se desea cargar, la configuracion del kernel debe ser habilitada mediante el puerto *K/I* y sincronizada utilizando el puerto *C_Valid*
     - o_KNorIMG       : Indica si los datos entregados desde la memoria deben ser cargados a los registros del Kernel o el sector de la imagen.
     
   
   
** FSM
**** I/O
     *Input*
     - _Clk_
     - _Rst_
     - _SoP_: Start of process, indica a la FSM que se ha terminado con la etapa de carga de datos y se debe comenzar con el procesamiento, al dar esa orden, la *FSM* pasa a tomar el control y lo retorna una vez terminado el procesamiento, a travez del puerto *EoP*
       + Un 0 indica que no se esta en la etapa de procesamiento
       + Un 1 indica que se debe dar inicio a la etapa de procesamiento
     - _ImgLength_: Puerto de [10] bits, donde se indica la altura de la imagen (en pixels), la *FSM* procesara los datos en memoria hasta alcanzar dicho tamaño
     - _Valid_: Indica cuando se deben incrementar las direcciones de memoria (*R_Addr* y *W_Addr*) con cada ciclo de clock
       + Un 1 habilita el incremento
       + Un 0 mantiene fija la direccion
     *OutPut*
     - _R_Addr_: [10] bits, es la direccion a ser leida en el proximo flanco de clock
     - _W_Addr_: [10] bits, es la direccion donde sera escrita la salida del modulo *CONV*
     - _EoP_: Indica que se ha finalizado la etapa de procesamiento poniendo la salida en alto
     - _Ch_block_: Usado en los estados de *LOAD* y *OUT*, indican al *MCU* que se ha finalizado la lectura de un bloque y se debe pasar al siguiente.
       + La salida esta en alto cuando se debe cambiar de bloque
** Memoria
**** I/O
     *Input*
     - _W_Addr_: Direccion donde se debe escribir el dato presente en *Data_In*
     - _R_Addr_: Direccion que indica el dato a ser leido a traves del puerto *Data_Out*
     - _Clk_
     - _WE_: Write Enable, habilita la escritura de los datos presentes en *Data_In* en la memoria
       + Un 1 habilita la escritura
       + Un 0 no permite la escritura
     - _Data_In_: Puerto de [8] bits, los datos presentes en este puerto seran escritos en la direccion inidicada por *W_Addr* si *WE* esta habilitado
     *Output*
     - _Data_Out_: Puerto de [8] bits, la salida representa los datos de la direccion inidicada por *R_Addr* en el ciclo anterior

** MCU
   Es el modulo encargado de la administracion de los bloques de memoria, hace de interfaz entre las memorias y el resto de los bloques. Se encarga del routeo de la informacion
**** I/O
     *Input*
     _ _CLK_
     - _Rst_
     - _i_DataConvN_: Puerto de [8] bits donde se escribe la salida del N-esimo modulo *CONV*
     - _Data_In_: Puerto de 3*[8] bits donde se escriben los valores de la imagen en la etapa de *LOAD*
     - _Ch_Block_: Utilizado durante los estados de *LOAD* y *OUT*, indica que se ha terminado de leer un bloque y se debe pasar al siguiente
       + Un estado alto indica el paso al siguiente bloque
     - _SoP_: Start of process, indica que se ha entrado al estado de *RUN*, se entregan los datos apuntados por *R_Addr* en los puertos *O_DataConvNM* y se escriben los datos presentes en los puertos *I_DataConvN* en las direcciones indicadas por *W_Addr*
       + Un estado alto indica el paso al estado *RUN*
     - _R_Addr_: [10]bits. Indica la direccion del dato a leer, si se esta en el estado de *RUN*, los datos leidos seran entregados por los puertos *O_DataConvNM*, caso contrario seran entregados al puerto *Data_Out*
     - _W_Addr_: [10]bits. Indica la direccion de memoria donde escribir los datos, si se esta en el estado de *RUN*, los datos escritos seran los que se encuentran en el puerto *i_DataConvN*, caso contrario seran los del puerto *Data_In*
     - _EoP_: Indica que se ha finalizado la etapa de procesamiento, es decir se sale del estado de *RUN* y se pasa al estado *OUT*, donde el *MCU* esta listo para entregar los datos de memoria a travez del puerto *Data_Out*
       + Un 1 indica que se esta en el estado *OUT*
       + Un 0 indica que se esta en cualquier otro estado
       
         *SoP* y *EoP* nunca deberian estar en 1 al mismo tiempo
     - _MemData_InN_: Puerto de [8] bits que recibe los datos de la N-esima memoria que se encuentran en la direccion indicada por *R_Addr*
     
     *Output*
     - _O_DataConvNM_: Puerto de [8] bits que tiene en su salida el dato que para el *InputM* del N-esimo modulo *CONV*
     - _WEN_: Write Enable para la N-esima memoria
     - _R_AddrN_: Puerto de [10] bits que indica la direccion de la N-esima memoria que se quiere leer
     - _W_AddrN_: Puerto de [10] bits que indica la direccion de la N-esima memoria donde se quiere escribir el dato que se encuentra en *MemData_Out* si *WE* lo permite
     - _Data_Out_: Puerto de 3*[8] bits donde se tiene el valor ubicado en la direccion indicada por *R_Addr* de 3 memorias
*** Algoritmo de routeo de la informacion
    
**** Introducción 
     Este algoritmo se desarrolló con el fin de poder realizar una implementación eficiente en lo que refiere a economía de recursos, trabajando con un FPGA (Field Programmable Gate Array) Artix-7.
**** ORGANIZACIÓN
     Se irá explicando paso a paso en cada etapa correspondiente al flujo de carga y/o trabajo, como procederá este algoritmo con cada módulo implementado. Se anexará la correspondiente arquitectura detallándola con imágenes y tablas. 
**** DESARROLLO
     *CARGA:*
     En la primera etapa(carga), se escriben todas consecutivamente. (col1 en mem1, col2 en mem2, y así sucesivamente.)

     Para la implementación en hardware sirve la asignación:
     |  0 |  0 | ... |    1 |
     |----+----+-----+------|
     | M1 | M2 | ... | Mn+2 |

     Por cada ciclo quedan 2 memorias que te ahorras de escribir, ya que las mismas se necesitan, pero ya están cargadas. Si k es el tamaño de kernell, k-1 memorias quedarían para reutilizar. Concluyendo esta etapa quedaría como última memoria cargada la n+2.
     Una vez que se termina de procesar, se carga empezando por la memoria siguiente a la última memoria que se terminó de cargar. Y se cargan N memorias.
     Por ejemplo: si N= 3 convolucionadores, y escribiste por último la memoria número 4, en la siguiente etapa escribirías las 5, la 1 y la 2 (respetando orden).

     *ROUTING:*
     
     De forma generalizada para N convolucionadores con un kernel de KxK, se tendran N+K-1 memorias, en cada iteracion se escriben unicamente N memorias, quedando las K-1 restantes con informacion que sera utilizada en la iteracion siguiente. La primer memoria en escribirse en cada ciclo ira rotando N lugares a la izquierda (si se escriben las memorias de izquierda a derecha).

     El rotar N lugares a la izquierda un arreglo de N+K-1 elementos, es equivalente a rotar (N+K-1)-N = K-1 elementos a la derecha. Si se considera cada posicion posible que puede tomar un elemento del arreglo como un estado, se tendran entonces

     E = p*(N+K-1)/(K-1) estados, donde p = min{x | x e Z ^ x*(N+K-1)/(K-1) e Z+}

     Para el caso particular de un kernel de 3x3:

     Van a haber E= N/2 + 1 estados. si N es par (siendo N el número de convolucionadores); y E = N+2 si N es impar. El primer estado se conformará de la siguiente forma:

     - M1: C11
     - M2: C12; C21
     - M3: C13; C22; C31
     - M4: C23; C32; C41
     - ...
     - Mn: C(n-2)3; C(n-1)2; CN1
     - Mn+1: C(n-1)3; Cn2
     - Mn+2: Cn3

     Donde:
     + Memoria :  convolucionador asignado
     + Los : (dos puntos) denotan ASIGNACIÓN ( tal memoria asignada a tal convolucionador).
     + Cxy =  x, convolucionador, y entrada del mismo.

     Para el siguiente estado, se efectúa una rotación circular, de N lugares.

     *IMPLEMENTACIÓN EN HARDWARE*
     Para generalizar, teniendo E estados, N convolucionadores, se tiene que se necesitarán 3 N multiplexores siendo N el número de convolucionadores, es decir, un multiplexor por cada input perteneciente al módulo del convolucionador.
     Cada multiplexor va a tener a su vez E entradas, y cada multiplexor corresponde a una de las entradas de un módulo convolucionador

     *ESCRITURA EN MEMORIA:*
     En el estado RUN.
     En cuanto a la salida de los módulos convolucionadores, se tienen varias etapas en función a las tareas de los mismos.
     La secuencia de escritura de la salida de los convolucionadores es la misma que la secuencia de escritura que la imagen en memoria.
     /Por ejemplo/: si se tienen 4 convolucionadores, su salida se escribirá primero en 1 2 3 4, y en el siguiente ciclo en 5 6 1 2.

     *JUSTIFICACION*
     Se optó por este algoritmo porque con esta implementación se hace uso de N + 2 memorias, siendo N el número de convolucionadores. Con otros algoritmos analizados, como por ejemplo que cada módulo se encargue de cierto sector, comenzando desde los extremos, no se tiene la misma eficiencia en cuanto a la economía de recursos, ya que se necesitan 3N memorias, e inclusive existía una etapa de solapamiento donde más de una memoria tenía cargado en los mismos datos.
     
