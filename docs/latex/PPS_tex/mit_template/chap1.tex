%% This is an example first chapter.  You should put chapter/appendix that you
%% write into a separate file, and add a line \include{yourfilename} to
%% main.tex, where `yourfilename.tex' is the name of the chapter/appendix file.
%% You can process specific files by typing their names in at the 
%% \files=
%% prompt when you run the file main.tex through LaTeX.
\chapter{Introducción}\label{intro_secc}

La convolucion bidimensional, se define matemáticamente como:
\begin{equation}\label{conv-org}
  G(x,y) = \sum_{i=0}^{m-1} \sum_{j=0}^{n-1}K(i,j)I(x-i,y-j)
\end{equation}
Donde $I(x,y)$ es una imagen de $(m \times n)$ pixels, $K(i,j)$ un conjunto de
coeficientes denominado kernel, de tamaño $(k \times k)$ and $G(x,y)$ es la
convolucion resultante de tamaño  $(m-2 \times n-2)$.

\section{Representación en punto fijo}\label{fixedpoint}

La representación en punto flotante, almacena los números en términos de la mantisa y del exponente. El hardware que soporta el formato punto flotante, luego de ejecutar cada computo, 
automáticamente escala la mantisa y actualiza el exponente para que el resultado se corresponda con el número de bits de forma definida. Todas estas operaciones hacen que el hardware que soporte punto flotante,
sea más costoso en términos de área y potencia. Emerge una alternativa: la representación en punto fijo.
Este formato se emplea para almacenar y manipular datos, con cierto número de bits fijos. Esto implica que luego del cómputo, no se sigue la posición del punto decimal, y
se le delega esta responsabilidad al diseñador del hardware. El punto decimal, valga la redundancia, es fijo para cada variable, y es predefinido.
Fijando el punto, una variable se limita a tomar un rango fijo de valores.
Pese a que este límite nos brinda ventajas en lo que refiere a utilización de recursos, si el resultado del cómputo cae fuera del rango, se produce un overflow. Existen varias
formas de manipular los overflows que emergen como resultado de un cómputo en punto fijo (redondeo, saturación, truncamiento) y sigue siendo responsabilidad del diseñador optar por
la representación adecuada según el sistema que pretende llevar a cabo.

FALTA: QUE REPRESENTACION USAMOS Y  PORQUE (GRAFICOS). NO LO PUSE PORQUE NO SE CON CUAL NOS QUEDAMOS AL FINAL

\section{Expansión dinámica de rango y Maximum Norm}\label{dynamicrange}
Los pixeles de la imagen en escala de grises $I(x,y)$ tienen un rango dinámico de valores que se hallan entre $[0,255]$,
y los valores que toma el kernel $K(x,y)$ pueden ser positivos o negativos.

Dado que el sistema desarrollado forma parte de un proyecto de Deep Learning,
donde es usual operar en un rango dinámico centrado en cero, se aplicó una
transformación denominada  expansión dinámica de rango ($\mathcal{D}([.])$),
junto con Maximum Norm ($(\mathcal{M}[.])$) para reacomodar los diferentes 
rangos de valores. 

Para el caso de la imagen, se tiene $\mathcal{D}[I(x,y)]=I^\prime(x,y)$ y un rango resultante de $[0,1]$.
Para el caso del kernel, $\mathcal{M}[K(x,y)]=K^\prime(x,y)$ con un rango $[-1,1]$, respectivamente.
Así, reemplazando en~\ref{conv-org}, se tiene 

\begin{equation}\label{conv-org1}
  G(x,y) = \mathcal{D}^{-1}\left[\sum_{i=0}^{m-1} \sum_{j=0}^{n-1}K^\prime(i,j)I^\prime(x-i,y-j)\right],
\end{equation}

siendo $\mathcal{D}^{-1}[.]$ el cambio de rango dinamico entre $[0,255]$ en la FPGA.

El proceso completo puede observarse en la Fig.~\ref{transformation}.

\begin{figure}
\centering
\includegraphics[scale=0.47]{wflow3}
\caption{Transformaciones del rango dinámico durante el procesamiento de la imagen.}
\label{transformation}
\end{figure}

\section{Flujo de diseño} \label{flujo_subsecc}

Se estructuró el proyecto y se siguió el flujo o estructura de la
Fig.~\ref{design_flow} para llevar el proyecto a cabo en el tiempo disponible.

En primera instancia se partió de las especificaciones, simulando el comportamiento en punto flotante mediante el lenguaje de alto nivel Python. Luego, se analizaron los resultados obtenidos tras implementar el sistema en punto fijo, a nivel software. 
Fijados los requerimientos se comenzó con la programación del hardware,
previamente habiendo estudiado y modelado la arquitectura del sistema, la cual
se detalla en la seccion \ref{arquitectura_sec}.

Como instancias intermedias se realizaron diferentes tipos de testing: test unitarios de cada módulo (test bench del módulo), test de integración (varios módulos y su interacción) y finalmente test de sistema, donde se probó el funcionamiento del sistema completo dada cierta imagen de entrada.

\begin{figure}
\centering
\includegraphics{flujo_de_dis.png}
\caption{Esquemático del flujo de diseño seguido.}
\label{design_flow}
\end{figure}

% \begin{figure}
% \centering
% \includegraphics{general_sch.png}
% \caption{Diagrama general del sistema: comunicación y lenguajes empleados.}
% \label{general}
% \end{figure}